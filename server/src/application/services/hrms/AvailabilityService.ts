// application/services/hrms/AvailabilityService.ts
// Availability Service Implementation

import type { 
  IAvailabilityRepository, 
  AvailableStaffQuery 
} from '../../../domain/interfaces/hrms/IAvailabilityRepository';
import type { EmployeeAvailability } from '../../../domain/entities/hrms/Availability';
import type { 
  CreateAvailabilityDTO, 
  UpdateAvailabilityDTO,
  BulkAvailabilityDTO,
  CalendarQueryDTO,
  AvailableStaffQueryDTO,
  AvailabilityResponseDTO,
  CalendarEntryResponseDTO,
  TeamSummaryResponseDTO,
  AvailableStaffResponseDTO
} from '../../dtos/hrms/AvailabilityDTO';
import { AvailabilityMapper } from '../../dtos/hrms/AvailabilityDTO';
import { NotFoundError, ValidationError } from '../../../shared/errors/AppError';

export class AvailabilityService {
  constructor(private availabilityRepository: IAvailabilityRepository) {}

  async getById(id: string): Promise<AvailabilityResponseDTO> {
    const availability = await this.availabilityRepository.findById(id);
    if (!availability) {
      throw new NotFoundError('Availability record not found');
    }
    return AvailabilityMapper.toResponseDTO(availability);
  }

  async getByEmployee(
    employeeId: string,
    startDate: string,
    endDate: string
  ): Promise<AvailabilityResponseDTO[]> {
    const records = await this.availabilityRepository.findByEmployee(
      employeeId,
      new Date(startDate),
      new Date(endDate)
    );
    return records.map(AvailabilityMapper.toResponseDTO);
  }

  async create(
    tenantId: string,
    userId: string,
    dto: CreateAvailabilityDTO
  ): Promise<AvailabilityResponseDTO> {
    // Check for conflicts
    const hasConflicts = await this.availabilityRepository.hasConflicts(
      dto.employeeId,
      new Date(dto.date),
      new Date(dto.date)
    );

    if (hasConflicts && dto.status !== 'AVAILABLE') {
      throw new ValidationError('Employee already has a conflicting availability record for this date');
    }

    const availability: Omit<EmployeeAvailability, 'id'> = {
      tenantId,
      employeeId: dto.employeeId,
      date: new Date(dto.date),
      startDate: dto.startDate ? new Date(dto.startDate) : undefined,
      endDate: dto.endDate ? new Date(dto.endDate) : undefined,
      status: dto.status,
      blockReason: dto.blockReason,
      notes: dto.notes,
      isAutoGenerated: false,
      createdAt: new Date(),
      updatedAt: new Date(),
      createdBy: userId,
    };

    const created = await this.availabilityRepository.create(availability);
    return AvailabilityMapper.toResponseDTO(created);
  }

  async createBulk(
    tenantId: string,
    userId: string,
    dto: BulkAvailabilityDTO
  ): Promise<AvailabilityResponseDTO[]> {
    const availabilities: Omit<EmployeeAvailability, 'id'>[] = dto.dates.map(date => ({
      tenantId,
      employeeId: dto.employeeId,
      date: new Date(date),
      status: dto.status,
      blockReason: dto.blockReason,
      notes: dto.notes,
      isAutoGenerated: false,
      createdAt: new Date(),
      updatedAt: new Date(),
      createdBy: userId,
    }));

    const created = await this.availabilityRepository.createBulk(availabilities);
    return created.map(AvailabilityMapper.toResponseDTO);
  }

  async update(id: string, dto: UpdateAvailabilityDTO): Promise<AvailabilityResponseDTO> {
    const existing = await this.availabilityRepository.findById(id);
    if (!existing) {
      throw new NotFoundError('Availability record not found');
    }

    const updated = await this.availabilityRepository.update(id, dto);
    if (!updated) {
      throw new NotFoundError('Failed to update availability record');
    }

    return AvailabilityMapper.toResponseDTO(updated);
  }

  async delete(id: string): Promise<void> {
    const existing = await this.availabilityRepository.findById(id);
    if (!existing) {
      throw new NotFoundError('Availability record not found');
    }

    if (existing.isAutoGenerated) {
      throw new ValidationError('Cannot delete auto-generated availability records');
    }

    await this.availabilityRepository.delete(id);
  }

  async getCalendarEntries(
    tenantId: string,
    query: CalendarQueryDTO
  ): Promise<CalendarEntryResponseDTO[]> {
    const entries = await this.availabilityRepository.getCalendarEntries(
      tenantId,
      new Date(query.startDate),
      new Date(query.endDate),
      query.employeeIds
    );
    return entries.map(AvailabilityMapper.toCalendarEntryDTO);
  }

  async getTeamSummary(
    tenantId: string,
    query: CalendarQueryDTO
  ): Promise<TeamSummaryResponseDTO[]> {
    const summaries = await this.availabilityRepository.getTeamSummary(
      tenantId,
      new Date(query.startDate),
      new Date(query.endDate),
      query.branchId
    );
    return summaries.map(AvailabilityMapper.toTeamSummaryDTO);
  }

  async getAvailableStaff(
    tenantId: string,
    query: AvailableStaffQueryDTO
  ): Promise<AvailableStaffResponseDTO[]> {
    const staffQuery: AvailableStaffQuery = {
      tenantId,
      startDate: new Date(query.startDate),
      endDate: new Date(query.endDate),
      branchId: query.branchId,
      category: query.category,
      excludeEmployeeIds: query.excludeEmployeeIds,
    };

    return this.availabilityRepository.getAvailableStaff(staffQuery);
  }

  async checkConflicts(
    employeeId: string,
    startDate: string,
    endDate: string,
    excludeId?: string
  ): Promise<boolean> {
    return this.availabilityRepository.hasConflicts(
      employeeId,
      new Date(startDate),
      new Date(endDate),
      excludeId
    );
  }

  // Auto-generate availability from leave/trip
  async blockForLeave(
    tenantId: string,
    employeeId: string,
    leaveId: string,
    startDate: Date,
    endDate: Date
  ): Promise<void> {
    const dates: Omit<EmployeeAvailability, 'id'>[] = [];
    const current = new Date(startDate);

    while (current <= endDate) {
      dates.push({
        tenantId,
        employeeId,
        date: new Date(current),
        status: 'ON_LEAVE',
        isAutoGenerated: true,
        sourceType: 'LEAVE',
        sourceId: leaveId,
        createdAt: new Date(),
        updatedAt: new Date(),
        createdBy: 'SYSTEM',
      });
      current.setDate(current.getDate() + 1);
    }

    await this.availabilityRepository.createBulk(dates);
  }

  async blockForTrip(
    tenantId: string,
    employeeId: string,
    tripId: string,
    startDate: Date,
    endDate: Date
  ): Promise<void> {
    const dates: Omit<EmployeeAvailability, 'id'>[] = [];
    const current = new Date(startDate);

    while (current <= endDate) {
      dates.push({
        tenantId,
        employeeId,
        date: new Date(current),
        status: 'ON_TRIP',
        isAutoGenerated: true,
        sourceType: 'TRIP',
        sourceId: tripId,
        createdAt: new Date(),
        updatedAt: new Date(),
        createdBy: 'SYSTEM',
      });
      current.setDate(current.getDate() + 1);
    }

    await this.availabilityRepository.createBulk(dates);
  }

  async releaseFromLeaveOrTrip(sourceType: string, sourceId: string): Promise<void> {
    await this.availabilityRepository.deleteBySource(sourceType, sourceId);
  }
}
