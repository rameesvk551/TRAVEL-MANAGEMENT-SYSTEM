// infrastructure/repositories/hrms/AvailabilityRepository.ts
// Availability Repository Implementation

import { Pool } from 'pg';
import type { 
  EmployeeAvailability, 
  AvailabilityCalendarEntry,
  TeamAvailabilitySummary,
  AvailableStaffQuery 
} from '../../../domain/entities/hrms/Availability';
import type { 
  IAvailabilityRepository,
  AvailabilityFilters 
} from '../../../domain/interfaces/hrms/IAvailabilityRepository';

export class AvailabilityRepository implements IAvailabilityRepository {
  constructor(private pool: Pool) {}

  async findById(id: string): Promise<EmployeeAvailability | null> {
    const query = `SELECT * FROM hrms.availability WHERE id = $1`;
    const result = await this.pool.query(query, [id]);
    return result.rows.length > 0 ? this.mapToEntity(result.rows[0]) : null;
  }

  async findByEmployee(employeeId: string, startDate: Date, endDate: Date): Promise<EmployeeAvailability[]> {
    const query = `
      SELECT * FROM hrms.availability 
      WHERE employee_id = $1 
        AND date >= $2 AND date <= $3
      ORDER BY date
    `;
    const result = await this.pool.query(query, [employeeId, startDate, endDate]);
    return result.rows.map(row => this.mapToEntity(row));
  }

  async findByDateRange(tenantId: string, startDate: Date, endDate: Date): Promise<EmployeeAvailability[]> {
    const query = `
      SELECT * FROM hrms.availability 
      WHERE tenant_id = $1 
        AND date >= $2 AND date <= $3
      ORDER BY date, employee_id
    `;
    const result = await this.pool.query(query, [tenantId, startDate, endDate]);
    return result.rows.map(row => this.mapToEntity(row));
  }

  async create(availability: Omit<EmployeeAvailability, 'id'>): Promise<EmployeeAvailability> {
    const query = `
      INSERT INTO hrms.availability (
        tenant_id, employee_id, date, start_date, end_date,
        status, block_reason, notes, is_auto_generated,
        source_type, source_id, created_by
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
      RETURNING *
    `;
    const result = await this.pool.query(query, [
      availability.tenantId,
      availability.employeeId,
      availability.date,
      availability.startDate,
      availability.endDate,
      availability.status,
      availability.blockReason,
      availability.notes,
      availability.isAutoGenerated,
      availability.sourceType,
      availability.sourceId,
      availability.createdBy,
    ]);
    return this.mapToEntity(result.rows[0]);
  }

  async createBulk(availabilities: Omit<EmployeeAvailability, 'id'>[]): Promise<EmployeeAvailability[]> {
    if (availabilities.length === 0) return [];
    
    const results: EmployeeAvailability[] = [];
    for (const avail of availabilities) {
      const created = await this.create(avail);
      results.push(created);
    }
    return results;
  }

  async update(id: string, availability: Partial<EmployeeAvailability>): Promise<EmployeeAvailability | null> {
    const updates: string[] = [];
    const params: unknown[] = [];
    let paramIndex = 1;

    const fieldMap: Record<string, string> = {
      status: 'status',
      blockReason: 'block_reason',
      notes: 'notes',
    };

    for (const [key, dbField] of Object.entries(fieldMap)) {
      if (key in availability) {
        updates.push(`${dbField} = $${paramIndex++}`);
        params.push((availability as Record<string, unknown>)[key]);
      }
    }

    if (updates.length === 0) return this.findById(id);

    updates.push(`updated_at = NOW()`);
    params.push(id);

    const query = `
      UPDATE hrms.availability
      SET ${updates.join(', ')}
      WHERE id = $${paramIndex}
      RETURNING *
    `;

    const result = await this.pool.query(query, params);
    return result.rows.length > 0 ? this.mapToEntity(result.rows[0]) : null;
  }

  async delete(id: string): Promise<boolean> {
    const query = `DELETE FROM hrms.availability WHERE id = $1`;
    const result = await this.pool.query(query, [id]);
    return (result.rowCount ?? 0) > 0;
  }

  async deleteBySource(sourceType: string, sourceId: string): Promise<number> {
    const query = `DELETE FROM hrms.availability WHERE source_type = $1 AND source_id = $2`;
    const result = await this.pool.query(query, [sourceType, sourceId]);
    return result.rowCount ?? 0;
  }

  async getCalendarEntries(
    tenantId: string, 
    startDate: Date, 
    endDate: Date,
    employeeIds?: string[]
  ): Promise<AvailabilityCalendarEntry[]> {
    let query = `
      SELECT 
        a.date,
        a.employee_id,
        CONCAT(e.first_name, ' ', e.last_name) as employee_name,
        a.status,
        a.notes as reason,
        t.name as trip_name,
        lt.name as leave_type
      FROM hrms.availability a
      JOIN hrms.employees e ON a.employee_id = e.id
      LEFT JOIN trips t ON a.source_type = 'TRIP' AND a.source_id = t.id::text
      LEFT JOIN hrms.leave_types lt ON a.source_type = 'LEAVE' 
        AND EXISTS (SELECT 1 FROM hrms.leave_requests lr WHERE lr.id::text = a.source_id AND lr.leave_type_id = lt.id)
      WHERE a.tenant_id = $1 AND a.date >= $2 AND a.date <= $3
    `;
    const params: unknown[] = [tenantId, startDate, endDate];

    if (employeeIds && employeeIds.length > 0) {
      query += ` AND a.employee_id = ANY($4)`;
      params.push(employeeIds);
    }

    query += ` ORDER BY a.date, e.first_name`;

    const result = await this.pool.query(query, params);
    return result.rows.map(row => ({
      date: row.date.toISOString().split('T')[0],
      employeeId: row.employee_id,
      employeeName: row.employee_name,
      status: row.status,
      reason: row.reason,
      tripName: row.trip_name,
      leaveType: row.leave_type,
    }));
  }

  async getTeamSummary(
    tenantId: string,
    startDate: Date,
    endDate: Date,
    branchId?: string
  ): Promise<TeamAvailabilitySummary[]> {
    let query = `
      WITH date_series AS (
        SELECT generate_series($2::date, $3::date, '1 day'::interval)::date as date
      ),
      staff_count AS (
        SELECT COUNT(*) as total FROM hrms.employees 
        WHERE tenant_id = $1 AND is_active = true
        ${branchId ? 'AND branch_id = $4' : ''}
      ),
      daily_stats AS (
        SELECT 
          a.date,
          COUNT(*) FILTER (WHERE a.status = 'AVAILABLE') as available,
          COUNT(*) FILTER (WHERE a.status = 'ON_TRIP') as on_trip,
          COUNT(*) FILTER (WHERE a.status = 'ON_LEAVE') as on_leave,
          COUNT(*) FILTER (WHERE a.status IN ('UNAVAILABLE', 'BLOCKED')) as unavailable
        FROM hrms.availability a
        JOIN hrms.employees e ON a.employee_id = e.id
        WHERE a.tenant_id = $1 AND a.date >= $2 AND a.date <= $3
        ${branchId ? 'AND e.branch_id = $4' : ''}
        GROUP BY a.date
      )
      SELECT 
        ds.date,
        sc.total as total_staff,
        COALESCE(st.available, sc.total - COALESCE(st.on_trip, 0) - COALESCE(st.on_leave, 0) - COALESCE(st.unavailable, 0)) as available,
        COALESCE(st.on_trip, 0) as on_trip,
        COALESCE(st.on_leave, 0) as on_leave,
        COALESCE(st.unavailable, 0) as unavailable
      FROM date_series ds
      CROSS JOIN staff_count sc
      LEFT JOIN daily_stats st ON ds.date = st.date
      ORDER BY ds.date
    `;

    const params: unknown[] = [tenantId, startDate, endDate];
    if (branchId) params.push(branchId);

    const result = await this.pool.query(query, params);
    return result.rows.map(row => ({
      date: row.date.toISOString().split('T')[0],
      totalStaff: parseInt(row.total_staff, 10),
      available: parseInt(row.available, 10),
      onTrip: parseInt(row.on_trip, 10),
      onLeave: parseInt(row.on_leave, 10),
      unavailable: parseInt(row.unavailable, 10),
    }));
  }

  async getAvailableStaff(query: AvailableStaffQuery): Promise<{
    employeeId: string;
    employeeName: string;
    category: string;
    skills: string[];
  }[]> {
    let sql = `
      SELECT DISTINCT
        e.id as employee_id,
        CONCAT(e.first_name, ' ', e.last_name) as employee_name,
        e.category,
        COALESCE(
          (SELECT array_agg(s.name) FROM hrms.employee_skills es 
           JOIN hrms.skills s ON es.skill_id = s.id 
           WHERE es.employee_id = e.id),
          ARRAY[]::text[]
        ) as skills
      FROM hrms.employees e
      WHERE e.tenant_id = $1 
        AND e.is_active = true
        AND NOT EXISTS (
          SELECT 1 FROM hrms.availability a 
          WHERE a.employee_id = e.id 
            AND a.date >= $2 AND a.date <= $3
            AND a.status NOT IN ('AVAILABLE', 'TENTATIVE')
        )
    `;
    const params: unknown[] = [query.tenantId, query.startDate, query.endDate];
    let paramIndex = 4;

    if (query.branchId) {
      sql += ` AND e.branch_id = $${paramIndex++}`;
      params.push(query.branchId);
    }

    if (query.category) {
      sql += ` AND e.category = $${paramIndex++}`;
      params.push(query.category);
    }

    if (query.excludeEmployeeIds && query.excludeEmployeeIds.length > 0) {
      sql += ` AND e.id != ALL($${paramIndex++})`;
      params.push(query.excludeEmployeeIds);
    }

    sql += ` ORDER BY e.first_name`;

    const result = await this.pool.query(sql, params);
    return result.rows.map(row => ({
      employeeId: row.employee_id,
      employeeName: row.employee_name,
      category: row.category,
      skills: row.skills || [],
    }));
  }

  async hasConflicts(employeeId: string, startDate: Date, endDate: Date, excludeId?: string): Promise<boolean> {
    let query = `
      SELECT COUNT(*) as count FROM hrms.availability 
      WHERE employee_id = $1 
        AND date >= $2 AND date <= $3
        AND status NOT IN ('AVAILABLE', 'TENTATIVE')
    `;
    const params: unknown[] = [employeeId, startDate, endDate];

    if (excludeId) {
      query += ` AND id != $4`;
      params.push(excludeId);
    }

    const result = await this.pool.query(query, params);
    return parseInt(result.rows[0].count, 10) > 0;
  }

  private mapToEntity(row: Record<string, unknown>): EmployeeAvailability {
    return {
      id: row.id as string,
      tenantId: row.tenant_id as string,
      employeeId: row.employee_id as string,
      date: new Date(row.date as string),
      startDate: row.start_date ? new Date(row.start_date as string) : undefined,
      endDate: row.end_date ? new Date(row.end_date as string) : undefined,
      status: row.status as EmployeeAvailability['status'],
      blockReason: row.block_reason as EmployeeAvailability['blockReason'],
      notes: row.notes as string | undefined,
      isAutoGenerated: row.is_auto_generated as boolean,
      sourceType: row.source_type as EmployeeAvailability['sourceType'],
      sourceId: row.source_id as string | undefined,
      createdAt: new Date(row.created_at as string),
      updatedAt: new Date(row.updated_at as string),
      createdBy: row.created_by as string,
    };
  }
}
